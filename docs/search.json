[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analisi Statistica Multivariata - Modelli Statistici & R",
    "section": "",
    "text": "Modelli Statistici & R è uno dei due moduli che formano l’insegnamento Analisi Statistica Multivariata. La pagina e-learning di riferimento per l’a.a. 2024/25 è raggiungibile al seguente link)."
  },
  {
    "objectID": "index.html#programma-dettagliato-del-corso",
    "href": "index.html#programma-dettagliato-del-corso",
    "title": "Analisi Statistica Multivariata - Modelli Statistici & R",
    "section": "Programma dettagliato del corso",
    "text": "Programma dettagliato del corso\n\nParte 1:\n\nIntroduzione al linguaggio R: utilizzo di R come calcolatrice scientifica; introduzione agli oggetti e alle loro classi (vettori, booleani, matrici, data.frame, liste); strutture condizionali e cicli; funzioni.\nStatistica descrittiva in R: rivisitazione dei principali argomenti di statistica descrittiva univariata e bivariata applicata a dataset, incluse rappresentazioni grafiche e loro personalizzazioni.\nCalcolo delle probabilità in R: principali funzioni per lavorare con variabili casuali; metodi Monte Carlo per approssimare integrali e probabilità.\nInferenza statistica in R: studio delle proprietà degli stimatori mediante simulazioni; metodi numerici per l’analisi di verosimiglianza.\n\n\n\nParte 2:\n\nVariabili casuali multidimensionali: funzione di densità e di ripartizione congiunte; marginalizzazione; momenti; vettore delle medie e matrice di varianze e covarianze; v.c. Normale multivariata e sue proprietà.\nSpecificazione del modello: fasi per la specificazione di un modello statistico; classificazione dei modelli.\nModello di regressione lineare semplice: assunzioni; interpretazione dei parametri; stima dei parametri (minimi quadrati e massima verosimiglianza); proprietà degli stimatori; teorema di Gauss-Markov; indice di determinazione lineare \\(R^2\\).\nVerifica ed utilizzo del modello: verifiche di ipotesi sul valore di un singolo coefficiente; verifica di ipotesi sulla bontà del modello; utilizzo del modello per fare previsione puntuale ed intervallare.\nDiagnostica del modello: metodi per valutare le assunzioni relative alla struttura del modello, agli errori e all’assenza di osservazioni inusuali.\nModello di regressione lineare multiplo: specificazione del modello in forma matriciale e sue assunzioni; interpretazione dei parametri; stima dei parametri (minimi quadrati e massima verosimiglianza); proprietà degli stimatori; teorema di Gauss-Markov; indice di determinazione multipla \\(R^2\\).\nVariabili qualitative: inserimento di variabili qualitative nel modello mediante l’inserimento di dummy; interazioni.\nVerifica di un sistema di ipotesi lineare: teoria generale e casi particolari.\nSelezione del modello: contributo assoluto e relativo di una variabile esplicativa; indice di determinazione parziale (IDP); selezione criterion-based delle variabili esplicative tramite approccio backward, forward e stepwise; AIC e BIC."
  },
  {
    "objectID": "index.html#esercizi-aggiuntivi",
    "href": "index.html#esercizi-aggiuntivi",
    "title": "Analisi Statistica Multivariata - Modelli Statistici & R",
    "section": "Esercizi aggiuntivi:",
    "text": "Esercizi aggiuntivi:\nUlteriori esercizi relativi alla Parte 1 del corso possono essere trovati al seguente link."
  },
  {
    "objectID": "index.html#link-a-r-e-rstudio",
    "href": "index.html#link-a-r-e-rstudio",
    "title": "Analisi Statistica Multivariata - Modelli Statistici & R",
    "section": "Link a R e RStudio",
    "text": "Link a R e RStudio\nAi seguenti link è possibile scaricare le ultime versioni di R e di RStudio."
  },
  {
    "objectID": "index.html#libri-di-testo",
    "href": "index.html#libri-di-testo",
    "title": "Analisi Statistica Multivariata - Modelli Statistici & R",
    "section": "Libri di testo",
    "text": "Libri di testo\n\nAlbert, J. & M. Rizzo (2012). R by Example. Springer.\nM. Grigoletto, F. Pauli, L. Ventura, Modello lineare, teoria e applicazioni con R. Giappichelli, 2017\nJ. Fox. Applied regression analysis and generalized linear models, third edition. Sage.\nD. Piccolo, D. Statistica, Terza edizione, Il Mulino."
  },
  {
    "objectID": "Esercizi.html",
    "href": "Esercizi.html",
    "title": "Esercizi R",
    "section": "",
    "text": "Si consideri \\(X \\sim N(\\mu, \\sigma^2)\\).\n\nSi calcoli il valore della funzione di densità di \\(X\\), \\(f(x)\\), in corrispondenza del punto \\(x=-1\\) considerando \\(\\mu = 1\\) e \\(\\sigma^2 = 2\\).\n\n\n\nSoluzione\nmu &lt;- 1\nsigma2 &lt;- 2\nx &lt;- -1\n\nf_x &lt;- (2*pi*sigma2)^(-1/2)*exp(-1/(2*sigma2)*(x-mu)^2); f_x\n\n\n\nMantenendo gli stessi valori per \\(\\mu\\) e \\(\\sigma^2\\), si rappresenti graficamente la densità di \\(X\\) nel range \\((-5, 5)\\).\n\n\n\nSoluzione\ncurve((2*pi*sigma2)^(-1/2)*exp(-1/(2*sigma2)*(x-mu)^2), xlim=c(-5,5),\n      ylab = \"f(x)\", xlab=\"x\")\n\n\n\nSi sovraimponga, al grafico precedente, una linea verticale in corrispondenza del punto \\(-3\\) ed una linea orizzontale in corrispondenza del punto \\(f(-3)\\).\n\n\n\nSoluzione\ncurve((2*pi*sigma2)^(-1/2)*exp(-1/(2*sigma2)*(x-mu)^2), xlim=c(-5,5),\n      ylab = \"f(x)\", xlab=\"x\")\nabline(h=f_x, v=-1, col=\"red\", lty=\"dashed\")\n\n\n\n\n\n\nSi sfrutti la funzione sum() per calcolare la somma dei primi \\(n = 600\\) numeri interi.\n\n\n\nSoluzione\nn &lt;- 600\nx &lt;- 1:n\n\nsum(x)\n\n\n\nSi può dimostrare che la somma dei primi \\(n\\) numeri interi è pari a \\(\\displaystyle \\sum_{i=1}^n i = \\frac{n(n+1)}{2}\\). Si utilizzi questo risultato per verificare la correttezza di quanto fatto al punto 1.\n\n\n\nSoluzione\nn &lt;- 600\nn*(n+1)/2\n\n\n\n\n\nSi crei un vettore v contenente i numeri interi da 1 a 250. 1. Si estraggano gli elementi in posizione pari e si calcoli la loro somma.\n\n\nSoluzione\nv &lt;- 1:250\nsum(v[2*(1:floor(length(v)/2))])\n\n\n\nSi utilizzi il vettore v per determinare il numero di interi tra 1 e 250 che sono maggiori di 97 e che sono numeri dispari.\n\n\n\nSoluzione\nv &lt;- 1:250\nbooleani &lt;- v &gt; 97 & (v%%2 == 1);booleani\nsum(booleani)\n\n\n\n\n\n\nSi scriva una funzione che, senza utilizzare la funzione t(), restituisca la trasposta di una matrice mat ricevuta come argomento.\nSi costruisca una matrica a piacere con cui verificare che il codice prodotto produca lo stesso risultato della funzione t().\n\n\n\nSoluzione\nA &lt;- matrix(c(1,3,4,2,9,0), ncol=2)\n\nmy_trasp &lt;- function(mat){\n  ncol_mat &lt;- ncol(mat)\n  nrow_mat &lt;- nrow(mat)\n  \n  trasp &lt;- matrix(NA, ncol=nrow_mat, nrow=ncol_mat)\n  \n  for(r in 1:nrow_mat){\n    trasp[,r] &lt;- mat[r,]\n  }\n  return(trasp)\n}\n\nA\nmy_trasp(A)\nt(A)\n\n\n\n\n\nSi scriva una funzione che permetta di calcolare il prodotto scalare tra due vettori di stessa lunghezza. Qualora i due vettori dati in input non dovessero avere la stessa lunghezza, la funzione deve portare ad un messaggio di errore.\n\n\nSoluzione\nprod_scal &lt;- function(a,b){\n  if(length(a) != length(b)){\n    print(\"Errore: i due vettori devono avere la stessa dimensione\")\n  } else {\n    somma &lt;- 0\n    for(i in 1:length(a)){\n      somma &lt;- somma + (a[i]*b[i])\n    }\n    return(somma)\n  }\n}\n\na &lt;- c(10, 2, 7)\nb &lt;- 4:6\nc &lt;- c(1, 1, 1, 1)\n\nprod_scal(a, b)\nprod_scal(a, c)\n\n\n\n\n\nSi scriva una funzione che riceva come argomento un numero intero e restituisca TRUE se il numero è primo e FALSE altrimenti.\n\n\nSoluzione\nis.primo &lt;- function(x){\n  divisori &lt;- 2:(x-1)\n  if(any(x%%divisori == 0)) {\n    return(FALSE)\n  } else {\n    return(TRUE)\n  }\n  \n}\n\nis.primo(9)\nis.primo(13)\n\n\n\n\n\n\nSi scriva una funzione che riceva come argomenti un vettore voti ed un vettore CFU. La funzione deve restituire una lista, avente come primo elemento la media aritmetica dei voti e come secondo elemento la media aritmetica ponderata degli stessi.\nSi utilizzi la funzione appena scritta per calcolare le medie dei propri voti, verificando la correttezza dei risultati tramite il proprio libretto online.\n\n\n\nSoluzione\nmedie &lt;- function(voti, CFU){\n  output &lt;- list()\n  output$media &lt;- sum(voti)/length(voti)\n  output$media_ponderata &lt;- sum(voti*CFU)/sum(CFU)\n  \n  return(output)\n}\n\nmiei_voti &lt;- rep(18, 7)\nmiei_CFU &lt;- c(6, 9, 9, 6, 9, 6, 6)\nmedie(miei_voti, miei_CFU)\n\nmiei_voti2 &lt;- c(27, 30, 18, 25, 30, 23, 30)\nmiei_CFU2 &lt;- c(6, 9, 9, 6, 9, 6, 6)\nmedie(miei_voti2, miei_CFU2)\n\n\n\n\n\nSi consideri un vettore numerico a piacere. 1. Si scriva una funzione che restituisca il vettore standardizzato.\n\n\nSoluzione\nx &lt;- seq(5, 271.2, by=.86)\n\nstand &lt;- function(v) {\n  s &lt;- (v-mean(v))/sd(v)\n  return(s)\n}\ns &lt;- stand(x)\nc(mean(s), sd(s))\n\n\n\nSi scriva una funzione che normalizzi il vettore (cioè scalare il vettore in modo tale che i suoi elementi assumano valori in \\([0,1]\\)).\n\n\n\nSoluzione\nx &lt;- seq(5, 271.2, by=.86)\n\nnorm &lt;- function(v) {\n  n &lt;- (v-min(v))/(max(v)-min(v))\n  return(n)\n}\nn &lt;- norm(x)\nc(min(n), max(n))\n\n\n\n\n\nSi implementi una funzione che riceve due interi \\(n\\) e \\(k\\) e restituisca una tavola pitagorica di dimensione \\(n \\times k\\).\n\n\nSoluzione\npitag &lt;- function(n, k){\n  out &lt;- matrix(NA, nrow=n, ncol=k)\n  \n  for(i in 1:n){\n    for(j in 1:k){\n      out[i,j] &lt;- i*j\n    }\n  }\n  return(out)\n}\n\npitag(5,4)\n\n\n\n\n\nIl seguente esercizio è estratto da un tema d’esame del prof. Rigon.\nI numeri di Stirling del secondo tipo \\(S(n,k)\\) rappresentano il numero di possibili partizioni di \\(n\\) oggetti formate da \\(k\\) elementi. Si può dimostrare che \\(\\displaystyle S(n,k) = \\frac{1}{k!} \\sum_{j=0}^k (-1)^{k-j} {k \\choose j} j^n,\\) per \\(k = 1, \\dots, n\\). Invece, il numero di Bell \\(B(n)\\) rappresenta il numero di possibili partizioni di un insieme di \\(n\\) elementi, indipendentemente dal numero di termini: \\(\\displaystyle B(n) = \\sum_{k=1}^n S(n,k)\\).\n\nSi scrivano le funzioni my_stirling(n,k) e my_bell(n) che calcolano, rispettivamente, \\(S(n,k)\\) e \\(B(n)\\).\n\n\n\nSoluzione\nmy_stirling &lt;- function(n,k){\n  j &lt;- 0:k\n  sum((-1)^(k-j)*choose(k,j)*j^n)/(factorial(k))\n}\n\nmy_bell &lt;- function(n){\n  stirling &lt;- numeric(n)\n  for(k in 1:n){\n    stirling[k] &lt;- my_stirling(n,k)\n  }\n  return(sum(stirling))\n}\n\n\n\nIn quanti modi è possibile dividere un insieme di 10 oggetti utilizzando 5 gruppi?\n\n\n\nSoluzione\nmy_stirling(10,5)\n\n\n\nIn quanti modi è possibile partizionare un insieme di 10 elementi?\n\n\n\nSoluzione\nmy_bell(10)"
  },
  {
    "objectID": "Esercizi.html#parte-1-introduzione-ad-r.",
    "href": "Esercizi.html#parte-1-introduzione-ad-r.",
    "title": "Esercizi R",
    "section": "",
    "text": "Si consideri \\(X \\sim N(\\mu, \\sigma^2)\\).\n\nSi calcoli il valore della funzione di densità di \\(X\\), \\(f(x)\\), in corrispondenza del punto \\(x=-1\\) considerando \\(\\mu = 1\\) e \\(\\sigma^2 = 2\\).\n\n\n\nSoluzione\nmu &lt;- 1\nsigma2 &lt;- 2\nx &lt;- -1\n\nf_x &lt;- (2*pi*sigma2)^(-1/2)*exp(-1/(2*sigma2)*(x-mu)^2); f_x\n\n\n\nMantenendo gli stessi valori per \\(\\mu\\) e \\(\\sigma^2\\), si rappresenti graficamente la densità di \\(X\\) nel range \\((-5, 5)\\).\n\n\n\nSoluzione\ncurve((2*pi*sigma2)^(-1/2)*exp(-1/(2*sigma2)*(x-mu)^2), xlim=c(-5,5),\n      ylab = \"f(x)\", xlab=\"x\")\n\n\n\nSi sovraimponga, al grafico precedente, una linea verticale in corrispondenza del punto \\(-3\\) ed una linea orizzontale in corrispondenza del punto \\(f(-3)\\).\n\n\n\nSoluzione\ncurve((2*pi*sigma2)^(-1/2)*exp(-1/(2*sigma2)*(x-mu)^2), xlim=c(-5,5),\n      ylab = \"f(x)\", xlab=\"x\")\nabline(h=f_x, v=-1, col=\"red\", lty=\"dashed\")\n\n\n\n\n\n\nSi sfrutti la funzione sum() per calcolare la somma dei primi \\(n = 600\\) numeri interi.\n\n\n\nSoluzione\nn &lt;- 600\nx &lt;- 1:n\n\nsum(x)\n\n\n\nSi può dimostrare che la somma dei primi \\(n\\) numeri interi è pari a \\(\\displaystyle \\sum_{i=1}^n i = \\frac{n(n+1)}{2}\\). Si utilizzi questo risultato per verificare la correttezza di quanto fatto al punto 1.\n\n\n\nSoluzione\nn &lt;- 600\nn*(n+1)/2\n\n\n\n\n\nSi crei un vettore v contenente i numeri interi da 1 a 250. 1. Si estraggano gli elementi in posizione pari e si calcoli la loro somma.\n\n\nSoluzione\nv &lt;- 1:250\nsum(v[2*(1:floor(length(v)/2))])\n\n\n\nSi utilizzi il vettore v per determinare il numero di interi tra 1 e 250 che sono maggiori di 97 e che sono numeri dispari.\n\n\n\nSoluzione\nv &lt;- 1:250\nbooleani &lt;- v &gt; 97 & (v%%2 == 1);booleani\nsum(booleani)\n\n\n\n\n\n\nSi scriva una funzione che, senza utilizzare la funzione t(), restituisca la trasposta di una matrice mat ricevuta come argomento.\nSi costruisca una matrica a piacere con cui verificare che il codice prodotto produca lo stesso risultato della funzione t().\n\n\n\nSoluzione\nA &lt;- matrix(c(1,3,4,2,9,0), ncol=2)\n\nmy_trasp &lt;- function(mat){\n  ncol_mat &lt;- ncol(mat)\n  nrow_mat &lt;- nrow(mat)\n  \n  trasp &lt;- matrix(NA, ncol=nrow_mat, nrow=ncol_mat)\n  \n  for(r in 1:nrow_mat){\n    trasp[,r] &lt;- mat[r,]\n  }\n  return(trasp)\n}\n\nA\nmy_trasp(A)\nt(A)\n\n\n\n\n\nSi scriva una funzione che permetta di calcolare il prodotto scalare tra due vettori di stessa lunghezza. Qualora i due vettori dati in input non dovessero avere la stessa lunghezza, la funzione deve portare ad un messaggio di errore.\n\n\nSoluzione\nprod_scal &lt;- function(a,b){\n  if(length(a) != length(b)){\n    print(\"Errore: i due vettori devono avere la stessa dimensione\")\n  } else {\n    somma &lt;- 0\n    for(i in 1:length(a)){\n      somma &lt;- somma + (a[i]*b[i])\n    }\n    return(somma)\n  }\n}\n\na &lt;- c(10, 2, 7)\nb &lt;- 4:6\nc &lt;- c(1, 1, 1, 1)\n\nprod_scal(a, b)\nprod_scal(a, c)\n\n\n\n\n\nSi scriva una funzione che riceva come argomento un numero intero e restituisca TRUE se il numero è primo e FALSE altrimenti.\n\n\nSoluzione\nis.primo &lt;- function(x){\n  divisori &lt;- 2:(x-1)\n  if(any(x%%divisori == 0)) {\n    return(FALSE)\n  } else {\n    return(TRUE)\n  }\n  \n}\n\nis.primo(9)\nis.primo(13)\n\n\n\n\n\n\nSi scriva una funzione che riceva come argomenti un vettore voti ed un vettore CFU. La funzione deve restituire una lista, avente come primo elemento la media aritmetica dei voti e come secondo elemento la media aritmetica ponderata degli stessi.\nSi utilizzi la funzione appena scritta per calcolare le medie dei propri voti, verificando la correttezza dei risultati tramite il proprio libretto online.\n\n\n\nSoluzione\nmedie &lt;- function(voti, CFU){\n  output &lt;- list()\n  output$media &lt;- sum(voti)/length(voti)\n  output$media_ponderata &lt;- sum(voti*CFU)/sum(CFU)\n  \n  return(output)\n}\n\nmiei_voti &lt;- rep(18, 7)\nmiei_CFU &lt;- c(6, 9, 9, 6, 9, 6, 6)\nmedie(miei_voti, miei_CFU)\n\nmiei_voti2 &lt;- c(27, 30, 18, 25, 30, 23, 30)\nmiei_CFU2 &lt;- c(6, 9, 9, 6, 9, 6, 6)\nmedie(miei_voti2, miei_CFU2)\n\n\n\n\n\nSi consideri un vettore numerico a piacere. 1. Si scriva una funzione che restituisca il vettore standardizzato.\n\n\nSoluzione\nx &lt;- seq(5, 271.2, by=.86)\n\nstand &lt;- function(v) {\n  s &lt;- (v-mean(v))/sd(v)\n  return(s)\n}\ns &lt;- stand(x)\nc(mean(s), sd(s))\n\n\n\nSi scriva una funzione che normalizzi il vettore (cioè scalare il vettore in modo tale che i suoi elementi assumano valori in \\([0,1]\\)).\n\n\n\nSoluzione\nx &lt;- seq(5, 271.2, by=.86)\n\nnorm &lt;- function(v) {\n  n &lt;- (v-min(v))/(max(v)-min(v))\n  return(n)\n}\nn &lt;- norm(x)\nc(min(n), max(n))\n\n\n\n\n\nSi implementi una funzione che riceve due interi \\(n\\) e \\(k\\) e restituisca una tavola pitagorica di dimensione \\(n \\times k\\).\n\n\nSoluzione\npitag &lt;- function(n, k){\n  out &lt;- matrix(NA, nrow=n, ncol=k)\n  \n  for(i in 1:n){\n    for(j in 1:k){\n      out[i,j] &lt;- i*j\n    }\n  }\n  return(out)\n}\n\npitag(5,4)\n\n\n\n\n\nIl seguente esercizio è estratto da un tema d’esame del prof. Rigon.\nI numeri di Stirling del secondo tipo \\(S(n,k)\\) rappresentano il numero di possibili partizioni di \\(n\\) oggetti formate da \\(k\\) elementi. Si può dimostrare che \\(\\displaystyle S(n,k) = \\frac{1}{k!} \\sum_{j=0}^k (-1)^{k-j} {k \\choose j} j^n,\\) per \\(k = 1, \\dots, n\\). Invece, il numero di Bell \\(B(n)\\) rappresenta il numero di possibili partizioni di un insieme di \\(n\\) elementi, indipendentemente dal numero di termini: \\(\\displaystyle B(n) = \\sum_{k=1}^n S(n,k)\\).\n\nSi scrivano le funzioni my_stirling(n,k) e my_bell(n) che calcolano, rispettivamente, \\(S(n,k)\\) e \\(B(n)\\).\n\n\n\nSoluzione\nmy_stirling &lt;- function(n,k){\n  j &lt;- 0:k\n  sum((-1)^(k-j)*choose(k,j)*j^n)/(factorial(k))\n}\n\nmy_bell &lt;- function(n){\n  stirling &lt;- numeric(n)\n  for(k in 1:n){\n    stirling[k] &lt;- my_stirling(n,k)\n  }\n  return(sum(stirling))\n}\n\n\n\nIn quanti modi è possibile dividere un insieme di 10 oggetti utilizzando 5 gruppi?\n\n\n\nSoluzione\nmy_stirling(10,5)\n\n\n\nIn quanti modi è possibile partizionare un insieme di 10 elementi?\n\n\n\nSoluzione\nmy_bell(10)"
  },
  {
    "objectID": "Esercizi.html#parte-2-descrittiva",
    "href": "Esercizi.html#parte-2-descrittiva",
    "title": "Esercizi R",
    "section": "Parte 2: Descrittiva",
    "text": "Parte 2: Descrittiva\n\nEsercizio 1\nSi considerino i dati presenti nel dataset Prestige del pacchetto carData, riguardanti un certo insieme di professioni, raccolti nel 1971 in Canada.\n\nQuante professioni sono state studiate? Quante variabili sono state raccolte?\n\n\n\nSoluzione\nlibrary(carData)\ndata(Prestige)\n\ndim(Prestige)\nnrow(Prestige)\nncol(Prestige)\n\n\n\nSi utilizzi la funzione help() per comprendere quali variabili sono state raccolte.\n\n\n\nSoluzione\nhelp(Prestige)\n\n\n\nSono presenti dei valori mancanti nel dataset? Se si, si crei un data.frame che esclude tutte le unità statistiche con almeno un mancante.\n\n\n\nSoluzione\nanyNA(Prestige)\n\nis.na(Prestige)\n\nquali_con_missing &lt;- rowSums(is.na(Prestige)) &gt; 0\nsum(quali_con_missing) # 4 unità da eliminare\nPrestige2 &lt;- subset(Prestige, !quali_con_missing)\n\n# Oppure:\nquali_complete &lt;- complete.cases(Prestige)\nPrestige2 &lt;- subset(Prestige, quali_complete)\n\n\n\nSi rappresenti graficamente la distribuzione delle variabile women. Si commenti questo grafico in relazione alle pari opportunità nel mondo del lavoro.\n\n\n\nSoluzione\nhist(Prestige2$women, prob = T, main = \"Istogramma variabile women\")\n\n\n\nSi ottenga la funzione di ripartizione empirica della variabile women. La si rappresenti graficamente e si ottenga il suo valore in corrispondenza di 50. Cosa ci dice questo valore, in merito alla disparità di genere?\n\n\n\nSoluzione\necdf_women &lt;- ecdf(Prestige2$women)\n\necdf_women(50)\n\nplot(ecdf_women)\n\n\n\nSi rappresenti graficamente la relazione congiunta di women ed income. Che relazione sembra esserci tra queste due variabili?\n\n\n\nSoluzione\nplot(Prestige2$women, Prestige2$income, pch = 20)\n\n\n\nSi colorino i punti del grafico precedente in modo tale che si possa tenere conto della tipologia del lavoro. Che informazioni si possono trarre?\n\n\n\nSoluzione\nplot(Prestige2$women, Prestige2$income, pch = 20, col = Prestige2$type)\nlevels(Prestige2$type) # neri = Colletti blu; rossi = Professionisti, manager e tecnici; verdi = colletti bianchi\n\n\n\nSi aggiunga al dataset una variabile women2. Questa variabile deve essere un factor avente tre livelli: “unbalanced_men” se women risulta minore o uguale a 40, “unbalance_women” se women è maggiore di 60 e “balanced” altrimenti. Si ottengano le frequenze assolute e relative di women2.\n\n\n\nSoluzione\nPrestige2$women2 &lt;- factor(ifelse(Prestige2$women &lt;= 40, \"unbalanced_man\",\n                        ifelse(Prestige2$women &gt; 60, \"unbalanced_women\", \"balanced\")))\n\ntable(Prestige2$women2)\ntable(Prestige2$women2)/nrow(Prestige2)\n\n\n\n\nEsercizio 2\nSi carichino in R i dati contenuti nel file Pokemon.csv, scaricabili al seguente link. Il dataset contiene dati circa 800 Pokémon e le seguetni variabili:\n\nID: l’ID del Pokémon;\nName: il nome del Pokémon;\nType1 e Type2: il tipo primario e quello secondario del Pokémon;\nTotal:la somma delle statistiche del Pokémon;\nHP: i punti vista (Health Points) del Pokémon;\nAttack e SpAtk: le statistiche attacco e attacco speciale del Pokémon;\nDefense e sPDef: le statistiche difesa e difesa speciale del Pokémon;\nSpeed: la statistica velocità del Pokémon;\nGeneration: la generazione del Pokémon;\nLegendary: stringa facente riferimento al fatto se il Pokémon è leggendario (True) o no (False).\n\n\n\nSoluzione\npkmn &lt;- read.table(\"Pokemon.csv\", header = TRUE, sep = \",\", \n                   stringsAsFactors = FALSE)\n\n\n\nSi ispezioni la variabile Legendary. Come mai non è di classe logi, pur avendo modalità associabili a “Vero” e “Falso”? Si sovrascriva la variabile con una sua versione logi.\n\n\n\nSoluzione\nstr(pkmn$Legendary)\ntable(pkmn$Legendary)\n\npkmn$Legendary &lt;- pkmn$Legendary == \"True\"\n\nstr(pkmn$Legendary)\ntable(pkmn$Legendary)\n\n\n\nSi eliminino dal dataset tutti i Pokémon che contengono nel loro nome la stringa “Mega”, ad eccezione del Pokémon chiamato “Meganium”. Per tale scopo, si utilizzi la funzione grep() (dall’help: grep(value = FALSE) returns a vector of the indices of the elements of x that yielded a match).\n\n\n\nSoluzione\nrighe_mega &lt;- grep(\"Mega\", pkmn$Name); righe_mega\n\nwhich(pkmn$Name == \"Meganium\")\n\n# Devo quindi eliminare tutte le righe indicate da righe_mega ad eccezione della 169\n\nwhich(righe_mega == 169)\nrighe_mega2 &lt;- righe_mega[-16]\n\n# Altro modo: mi accorgo che tutti i nomi con Mega, ad eccezione di Meganium, hanno uno spazio (blank) dopo la parola Mega:\npkmn$Name[righe_mega]\nrighe_mega2 &lt;- grep(\"Mega \", pkmn$Name); righe_mega2\n\npkmn &lt;- pkmn[-righe_mega,]\n\n\n\nSi crei un dataset pkmn_sub contenente i dati dei Pokémon appartenenti alla prima o alla seconda generazione. D’ora in poi, si faccia riferimento a questo data.frame.\n\n\n\nSoluzione\npkmn_sub &lt;- subset(pkmn, Generation == 1 | Generation == 2)\n\n\n\nSi codifichino in factor le variabili che si ritiene sensato lo siano.\n\n\n\nSoluzione\npkmn_sub$Type1 &lt;- as.factor(pkmn_sub$Type1)\npkmn_sub$Type2 &lt;- as.factor(pkmn_sub$Type2)\npkmn_sub$Generation &lt;- as.factor(pkmn_sub$Generation)\n\n\n\nCome si distribuiscono i Pokémon leggendari tra le due generazioni considerate? Si misuri il grado di connessione con un opportuno indice.\n\n\n\nSoluzione\ntt &lt;- table(pkmn_sub$Generation, pkmn_sub$Legendary); tt\nplot(tt)\n\nmarginali_gen &lt;- as.numeric(table(pkmn_sub$Generation))\nmarginali_leg &lt;- as.numeric(table(pkmn_sub$Legendary))\n\nn_gen &lt;- length(marginali_gen)\nn_leg &lt;- length(marginali_leg)\nn &lt;- nrow(pkmn_sub)\n\nfreq_attese &lt;- matrix(NA, nrow = n_gen, ncol = n_leg)\n\nchi2 &lt;- 0\n\nfor(i in 1:n_gen){\n  for(j in 1:n_leg){\n    freq_attese[i,j] &lt;- marginali_gen[i]*marginali_leg[j]/n\n    \n    chi2 &lt;- chi2 + (((tt[i,j] - freq_attese[i,j])^2)/(freq_attese[i,j]))\n  }\n}\nchi2\n\nchi2_max &lt;- n*min(n_gen-1, n_leg - 1)\nchi2_Norm &lt;- chi2/chi2_max; chi2_Norm\n\n\n\nSi calcoli, tramite la sua definizione, il valore della covarianza tra Attack e Defense. Si confronti il risultato ottenuto con quello fornito dalla funzione cov().\n\n\n\nSoluzione\nmy_cov &lt;- mean( (pkmn_sub$Attack - mean(pkmn_sub$Attack))*(pkmn_sub$Defense - mean(pkmn_sub$Defense))); my_cov\n\ncov(pkmn_sub$Attack, pkmn_sub$Defense)\ncov(pkmn_sub$Attack, pkmn_sub$Defense)*(n-1)/n\n\n\n\nSi ottengano i boxplot relativi alla distribuzione di Attack condizionata per Type1.\n\n\n\nSoluzione\nboxplot(pkmn_sub$Attack ~ pkmn_sub$Type1, xlab = \"Tipo1\", ylab = \"Attacco\")\n\n\n\nSi proponga un modo per ottenere le medie condizionate di Attack entro ogni modalità di Type1.\n\n\n\nSoluzione\nquanti_tipi &lt;- length(unique(pkmn_sub$Type1))\nmedie_condiz &lt;- numeric(quanti_tipi)\nnames(medie_condiz) &lt;- levels(pkmn_sub$Type1)\n\nmodalita_type &lt;- levels(pkmn_sub$Type1)\n\nfor(i in 1:quanti_tipi){\n  data_temp &lt;- subset(pkmn_sub, Type1 == modalita_type[i])\n  \n  medie_condiz[i] &lt;- mean(data_temp$Attack)\n}\n\n# Oppure:\nhelp(aggregate)\nmedie_condiz_2 &lt;- aggregate(Attack ~ Type1, data = pkmn_sub, FUN = mean, na.rm = TRUE)\n\nmedie_condiz\nmedie_condiz_2\n\n\n\nSi costruisca un data.frame contenente esclusivamente le variabili quantitative di pkmn_sub. Si utilizzi questo data.frame per costruire la matrice di correlazione (arrotondata alla terza cifra decimale) e la matrice di diagrammi a dispersione. Si colorino i punti dei diagrammi a dispersione sulla base del valore di Legendary.\n\n\n\nSoluzione\npkmn_quantit &lt;- subset(pkmn_sub, select = Total:Speed)\n# pkmn_quantit &lt;- subset(pkmn_sub, select = c(Total, HP, Attack, Defense, SpAtk, SpDef, Speed))\n\nround(cor(pkmn_quantit), 3)\nplot(pkmn_quantit, pch = 20, col = as.factor(pkmn_sub$Legendary))\n\n\n\n\nEsercizio 3\nSi consideri il dataset flights del pacchetto nycflights13, relativo a voli aerei partiti da aeroporti di New York nel 2013. Una volta caricato il dataset, si guardi la relativa pagina di help per comprendere le variabili presenti.\nL’oggetto flights è di classe tibble, una classe proposta negli ultimi anni per gestire dataset in modo differente rispetto ai classici data.frame. Possiamo definire i tibble come una sottoclasse dei data.frame (quindi tutti i tibble sono data.frame, ma non tutti i data.frame sono tibble). Si faccia riferimento a questo link per maggiori informazioni.\n\n\nSoluzione\nlibrary(nycflights13)\ndata(\"flights\")\nclass(flights)\n\nhelp(\"flights\")\n\n\n\nSi sovrascriva l’oggetto flights, forzando la sua classe ad essere data.frame. (N.B.: in generale non è obbligatorio convertire la classe di un tibble per lavorare con esso.)\n\n\n\nSoluzione\nflights &lt;- as.data.frame(flights)\n\n\n\nQuale dei tre aeroporti di New York è quello da cui sono partiti più voli nel 2013?\n\n\n\nSoluzione\ntt &lt;- table(flights$origin); tt\n\nnames(tt)[which.max(tt)]\n\n\n\nSi vuole indagare l’eterogeneità della variabile month, per valutare quindi se le partenze possono ritenersi equiripartite nei mesi dell’anno. Si calcolino quindi l’indice di Gini normalizzato e l’indice di Shannon normalizzato.\n\n\n\nSoluzione\ntt_month &lt;- table(flights$month)\nf &lt;- tt_month/sum(tt_month)\nk &lt;- length(f)\nG &lt;- sum(f*(1-f))\nG_N &lt;- G*k/(k-1); G_N\n\nH &lt;- -sum(f*log(f))\nH_N &lt;- H/log(k); H_N\n\n\n\nSi aggiunga al dataset una variabile factor chiamata arrival e che assuma modalità “hearly”, “on time” e “delay” sulla base del fatto che l’aereo sia arrivato in anticipo, puntuale o in ritardo.\n\n\n\nSoluzione\nflights$arrival &lt;- \n  factor(ifelse(flights$arr_delay &lt; 0, \"early\",\n            ifelse(flights$arr_delay &gt; 0, \"delay\", \n                   \"on time\")))\ntable(flights$arrival)\n\n\n\nSi aggiunga al dataset una nuova variabile total_delay, data dalla somma del ritardo alla partenza e ritardo all’arrivo.\n\n\n\nSoluzione\nflights$total_delay &lt;- flights$dep_delay + flights$arr_delay\n\n\n\nSi calcoli il ritardo totale medio per compagnia aerea (in inglese carrier). Quale compagnia sembra essere la più efficiente, sulla base di questa piccola analisi?\n\n\n\nSoluzione\nmedia_ritardi &lt;- aggregate(total_delay ~ carrier, data = flights, FUN = mean, na.rm = TRUE)\n\n# altrimenti possiamo procedere filtrando:\n\nmedia_ritardi_2 &lt;- numeric(length(unique(flights$carrier)))\nnames(media_ritardi_2) &lt;- unique(flights$carrier)\n\nfor(i in 1:length(unique(flights$carrier))){\n  sub &lt;- \n    subset(flights, carrier == unique(flights$carrier)[i])\n  \n  media_ritardi_2[i] &lt;- mean(sub$total_delay, na.rm = T)\n}\n\nmedia_ritardi\nmedia_ritardi_2\n\nwhich.min(media_ritardi_2)\n\n\n\nSi proponga un metodo per costruire la variabile route (tratta). Si determini quante sono le tratte osservate e quale, tra queste, è la più frequentata.\n\n\n\nSoluzione\nflights$route &lt;- paste(flights$origin, \" - \", flights$dest, sep=\"\")\n\nlength(unique(flights$route))\n\ntt_route &lt;- table(flights$route)\nnames(tt_route)[which.max(tt_route)]\n\n\n\nIn future analisi legate al turismo, si sarà interessati a studiare i soli voli decollati nel periodo estivo. A tal fine, si costruisca un dataset flights_summer riguardanti i voli partiti dal 1 giugno al 31 agosto.\n\n\n\nSoluzione\nflights_summer &lt;- subset(flights, month %in% c(6,7,8))\n\n\n\n\nEsercizio 4\nSi consideri il dataset olympics.RData (scaricabile al seguente link), contenente dati relativi alle Olimpiadi di Londra 2012. In particolare, il dataset contiente le seguenti variabili:\n\nCountry: nome del paese;\nGoldMedals: numero di medaglie d’oro vinte a Londra 2012;\nSilver: numero di medaglie d’argento vinte a Londra 2012;\nBronze: numero di medaglie di bronzo vinte a Londra 2012;\nTotalMedals: numero totale di medaglie vinte a Londra 2012;\nIncome: reddito pro capite (in 10,000$);\nPopnSize: popolazione del paese (in miliardi);\nGDP: gross domestic product (PIL).\n\n\nSi carichi in memoria il dataset.\n\n\n\nSoluzione\nload(\"olympics.RData\")\n\n\n\nSi modifichi il nome della variabile GoldMedals in Gold.\n\n\n\nSoluzione\ncolnames(Olympics)[2] &lt;- \"Gold\"\n\n\n\nSi modifichi il data.frame in modo tale che il nome delle righe corrisponda al nome del paese. Rimuovere quindi eventuali variabili divenute ormai ridondanti.\n\n\n\nSoluzione\nrownames(Olympics) &lt;- Olympics$Country\nOlympics &lt;- subset(Olympics, select=-Country)\n\n\n\nQual è il paese che ha vinto il minor numero di medaglie d’oro? E quello che ha vinto complessivamente meno medaglie?\n\n\n\nSoluzione\nOlympics[which.min(Olympics$Gold),]\nOlympics[which.min(Olympics$TotalMedals),]\n\n\n\nSi definisca una finestra grafica che possa contenere quattro grafici, distribuiti su due righe e due colonne. Il grafico in alto a sinistra deve contenere una opportuna rappresentazione grafica della variabile TotalMedals, mentre i restanti tre devono essere diagrammi a dispersione tra la variabile TotalMedals e Income, PopnSize e GDP.\n\n\n\nSoluzione\npar(mfrow=c(2,2))\nplot(table(Olympics$TotalMedals), ylab = \"Freq.\", xlab = \"Medaglie totali\")\nplot(Olympics$TotalMedals ~ Olympics$Income, pch=20, ylab=\"Medaglie totali\", xlab=\"Reddito\")\nplot(Olympics$TotalMedals ~ Olympics$PopnSize, pch=20, ylab=\"Medaglie totali\", xlab=\"Popolazione\")\nplot(Olympics$TotalMedals ~ Olympics$GDP, pch=20, ylab=\"Medaglie totali\", xlab=\"PIL\")\npar(mfrow=c(1,1))\n\n\n\nCreare un data.frame denominato medals_composition che riporti solo i paesi che hanno conquistato almeno una medaglia e la composizione delle medaglie vinte da ciascun paese, specificata in base alle diverse tipologie di medaglie. Più precisamente, si deve costruire un dataset con tre variabili contenenti, rispettivamente, la proporzione di medaglie d’oro, d’argento e di bronzo vinte da ciascun paese.\n\n\n\nSoluzione\nmedals_composition &lt;- \n  subset(Olympics, \n         TotalMedals &gt; 0,\n         select=c(Gold, Silver, Bronze))\n\nmedals_composition &lt;- t(apply(medals_composition, 1, function(x) x/sum(x)))\n\n\n\nUna caratteristica dei dati composizionali è che ogni unità statistica è associata ad un vettore con elementi positivi i quali sommano a 1. Si verifichino queste due caratteristiche in merito al dataset medals_composition.\n\n\n\nSoluzione\nall(apply(medals_composition, 1, function(x) all(x &gt;= 0)))\n\nall(rowSums(medals_composition) == 1)\n\n\n\nSi noti che, per via del vincolo di somma a 1, la matrice di varianze e covarianze di dati composizionali è a rango non pieno. Infatti, è possibibile dimostrare che la somma di ogni riga (o di ogni colonna) vale 0.\nSi ottenga la matrice di varianze e covarianze del dataset medals_composition e si verifichi tale proprietà.\n\n\n\nSoluzione\nSigma &lt;- cov(medals_composition)\n\ncolSums(Sigma)\nrowSums(Sigma)\n\n\n\n\nEsercizio 5\nSi importi il dataset , scaricabile al seguente link, contenente informazioni su 38 specie di animali. In particolare si hanno le seguenti variabili:\n\nspecie_tr: specie dell’animale;\npeso_corpo: peso del corpo, in Kg;\npeso_cerv: peso del cervello, in grammi;\nleggero: numero di ore di sonno leggero (ore al giorno);\nprofondo: numero di ore di sonno profondo (ore al giorno);\nanni_vita: speranza di vita alla nascita, in anni;\ngestazione: tempo di gestazione, in giorni\npreda: indice qualitativo di predazione (0 = raramente è una preda, 1 = è molto spesso una preda);\nesposto: indice qualitativo di esposizione durante il sonno (0 = poco esposto, 1 = molto esposto);\npericolo: indice qualitativo di pericolo (0 = gli altri animali non rappresentano un pericolo per lui, 1 = gli altri animali rappresentano un grave pericolo per lui).\n\n1 - Convertire le variabili qualitative in factor.\n\n\nSoluzione\nanimals &lt;- read.table(\"animals.csv\", header = T, sep = \";\")\n\n\n\nanimals$preda &lt;- as.factor(animals$preda)\nanimals$esposto &lt;- as.factor(animals$esposto)\nanimals$pericolo &lt;- as.factor(animals$pericolo)\n\n\n\nSi calcoli una nuova variabile sonno, rappresentante il numero totale di ore di sonno giornaliere.\n\n\n\nSoluzione\nanimals$sonno &lt;- animals$leggero + animals$profondo\n\n\n\nQuale animale dorme complessivamente di più? E quale dorme di meno?\n\n\n\nSoluzione\nanimals$specie_tr[which.max(animals$sonno)]\nanimals$specie_tr[which.min(animals$sonno)]\n\n\n\nSi ottenga il quantile di ordine 0.6 della variabile sonno e lo si interpreti.\n\n\n\nSoluzione\nquantile(animals$sonno, probs = .6)\n\n\n\nSi proponga un opportuno grafico per studiare la relazione tra sonno e peso_cerv. Si commenti il risultato ottenuto.\n\n\n\nSoluzione\nplot(animals$sonno ~ animals$peso_cerv, pch = 20, main = \"Sonno - Peso Cervello\", xlab = \"Peso cervello\", ylab = \"Sonno\")\n\n\n\nSi proponga un opportuno grafico per studiare la relazione tra sonno e preda. Si commenti il risultato ottenuto.\n\n\n\nSoluzione\nboxplot(animals$sonno ~ animals$preda, pch = 20, main = \"Sonno - Preda\", xlab = \"Preda\", ylab = \"Sonno\")\n\n\n\nSi ritiene possibile proporre un grafico per studiare la relazione tra sonno e peso_cerv, tenendo conto anche della presenza della variabile preda? Se si, si riporti tale grafico e lo si commenti. Altrimenti si motivi il perché non lo si ritiene possibile.\n\n\n\nSoluzione\nplot(animals$sonno ~ animals$peso_cerv, col = animals$preda, pch = 20, main = \"Sonno - Peso Cervello\", xlab = \"Peso cervello\", ylab = \"Sonno\")\n\nlevels(animals$preda)\n# neri: 0\n# rossi: 1"
  },
  {
    "objectID": "Esercizi.html#parte-3-probabilità",
    "href": "Esercizi.html#parte-3-probabilità",
    "title": "Esercizi R",
    "section": "Parte 3: Probabilità",
    "text": "Parte 3: Probabilità\n\nEsecizio 1\n\nSi rappresentino graficamente e sullo stesso grafico le funzioni di densità di una variabile casuale \\(\\chi^2_g\\) con \\(g \\in \\{1, 2, 5, 10\\}\\), differenziando le linee delle curve a piacere. Si costruisca anche un’opportuna legenda.\n\n\n\nSoluzione\ncurve(dchisq(x, 1), xlim=c(0,40))\ncurve(dchisq(x, 2), add = T, col=\"red\", lty=\"dashed\")\ncurve(dchisq(x, 5), add = T, col=\"blue\", lty=\"dotted\")\ncurve(dchisq(x, 10), add = T, col=\"green\", lty=\"dotdash\")\nlegend(20, .5, \n       c(\"g = 1\",\"g = 2\",\"g = 5\",\"g = 10\"),\n       col=c(\"black\",\"red\",\"blue\",\"green\"),\n       lty=c(\"solid\",\"dashed\",\"dotted\",\"dotdash\"),\n    bty=\"n\")\n\n\n\nSi ricorda che se \\(Y \\sim Gamma(g/2, 1/2)\\), allora \\(Y \\sim \\chi^2_g\\). Si fissi \\(g = 50\\) e si estraggano 5000 valori da una \\(Gamma(g/2, 1/2)\\) e si confronti la distribuzione empirica ottenuta con quella di una \\(\\chi^2_g\\).\n\n\n\nSoluzione\nset.seed(42)\ng &lt;- 50\ngamma &lt;- rgamma(5000, g/2, rate = .5)\n\npar(mfrow=c(1,2))\nhist(gamma, prob = T, main = \"Istogramma valori estratti da Gamma\")\ncurve(dchisq(x, g), col = 2, add = T)\nplot(ecdf(gamma))\ncurve(pchisq(x, g), col = 2, add = T)\npar(mfrow=c(1,1))\n\n\n\nSi ricorda che se \\(X_1, \\dots, X_g\\) sono i.i.d. e \\(X_j \\sim N(0,1)\\), allora \\(\\displaystyle \\sum_{j=1}^g X_j \\sim \\chi^2_g\\). Si uti questo risultato teorico per ottenere un campione di 8000 valori da una \\(\\chi^2_10\\) sfruttando unicamente la funzione rnorm().\n\n\n\nSoluzione\nB &lt;- 8000\ng &lt;- 10\n# Tanti, tanti modi. Ne vediamo due:\n\n# Primo, poco efficiente:\nchi2_10_primo &lt;- numeric(B)\n\nset.seed(42)\nfor(b in 1:B){\n  chi2_10_primo[b] &lt;- sum(rnorm(g, mean = 0, sd = 1)^2)\n}\n\n\n# Secondo:\nvalori_normale &lt;- matrix(rnorm(B*g)^2, ncol = g, nrow = B)\nchi2_10_secondo &lt;- rowSums(valori_normale)\n\npar(mfrow=c(1,2))\nhist(chi2_10_primo, prob = T, main=\"Proposta 1\")\ncurve(dchisq(x, g), add = T, col = \"red\")\n\nhist(chi2_10_secondo, prob = T, main=\"Proposta 2\")\ncurve(dchisq(x, g), add = T, col = \"red\")\npar(mfrow=c(1,1))\n\n\n\nNell’inferenza è spesso necessario ricavare ricavare dei quantili di una \\(\\chi^2_g\\). Si utilizzi R per ottenere il quantile di ordine 0.95 di una \\(\\chi^2_{10}\\) in due modi differenti, uno esatto ed uno approssimato.\n\n\n\nSoluzione\nqchisq(.95, 10)\n\nquantile(chi2_10_primo, probs = .95)\n\n\n\n\nEsercizio 2 (difficile):\nIn una foresta incantata, alla fine del giorno 0 vengono piantati 6 semi magici. Dal giorno 1 in avanti, alla fine di ogni giornata, ogni seme ha una probabilità del 50% di trasformarsi in un albero. Una volta trasformato, esso resterà un albero per sempre. Si implementi una simulazione per approssimare il numero atteso (medio) di giorni necessari affinchè tutti i semi diventino degli alberi.\nLa fonte dell’esercizio e la sua risoluzione analitica, possono essere trovati in questo video.\n\n\nSoluzione\nn &lt;- 6\nnsim &lt;- 50000\n\ndays &lt;- numeric(nsim)\nfor(s in 1:nsim){\n  tree &lt;- numeric(n)\n  d &lt;- 0 # giorno 0\n  succ &lt;- 0 # quanti semi sono diventati alberi\n  \n  while(succ &lt; 6){\n    tree[which(tree==0)] &lt;- rbinom(sum(tree==0),1,.5)\n    succ &lt;- sum(tree)\n    d &lt;- d+1\n  }\n  days[s] &lt;- d\n}\n\nmean(days)\n\n# Oppure:\nmean(replicate(nsim, max(rgeom(6,0.5))+1))\n\n\n\n\nEsercizio 3\nSiano \\(p_1(x)\\) e \\(p_2(x)\\) due funzioni di probabilità associate a due variabili casuali discrete \\(X_1\\) e \\(X_2\\) caratterizzate sullo stesso supporto \\(\\mathcal{S} = \\{x_1, \\dots, x_k\\}\\). La divergenza dii Kullback-Leibler di \\(X_1\\) da \\(X_2\\) è definita come \\(KL(p_1 || p_2) = \\displaystyle \\sum_{j=1}^k p_1(x_j) \\log \\frac{p_1(x_j)}{p_2(x_j)}\\)\n\nSi calcoli il valore della divergenza di Kullback-Leibler di \\(X_1\\) da \\(X_2\\) considerando \\(X_1\\) e \\(X_2\\) distribuite come Binomiali di parametro \\(n = 20\\) e probabilità di successo \\(\\theta_1 = 0.2\\) e \\(\\theta_2 = 0.1\\).\n\n\n\nSoluzione\nn &lt;- 20\ntheta1 &lt;- 0.2\ntheta2 &lt;- 0.1\n\np1 &lt;- dbinom(0:n, n, theta1)\np2 &lt;- dbinom(0:n, n, theta2)\n\nsum(p1*log(p1/p2))\n\n\n\nLa divergenza di Kullback-Leibler gode della proprietà di simmetria?\n\n\n\nSoluzione\nn &lt;- 20\ntheta1 &lt;- 0.2\ntheta2 &lt;- 0.1\n\np1 &lt;- dbinom(0:n, n, theta1)\np2 &lt;- dbinom(0:n, n, theta2)\n\nKL_x1_da_x2 &lt;- sum(p1*log(p1/p2))\nKL_x2_da_x1 &lt;- sum(p2*log(p2/p1))\n\nKL_x1_da_x2; KL_x2_da_x1\n\n\n\nSi calcoli la stessa quantità facendo variare \\(\\theta_2 \\in \\{0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9\\}\\). Da questi risultati è possibile intuire cosa misura questo indice?\n\n\n\nSoluzione\nn &lt;- 20\ntheta1 &lt;- 0.2\ntheta2_vec &lt;- c(.05, .1, .2, .3, .5, .7, .9)\n\np1 &lt;- dbinom(0:n, n, theta1)\n\nKL &lt;- numeric(length(theta2_vec))\n\nfor(i in 1:length(theta2_vec)){\n  theta2 &lt;- theta2_vec[i]\n  \n  p2 &lt;- dbinom(0:n, n, theta2)\n\n  KL[i] &lt;- sum(p1*log(p1/p2))\n}\nplot(theta2_vec, KL)\n\n\n\nCi si convinca che \\(\\displaystyle KL(p_1 || p_2) = \\mathbb{E}\\left[\\log\\left\\{\\frac{p_1(X_1)}{p_2(X_1)} \\right\\} \\right]\\). Si utilizzi questo risultato per ottenere un’approssimazione Monte Carlo di quanto ottenuto al punto 1.\n\n\n\nSoluzione\nB &lt;- 8000\nn &lt;- 20\ntheta1 &lt;- .2\ntheta2 &lt;- .1\nKL_sim &lt;- numeric(B)\n\nfor(b in 1:B){\n  x_j &lt;- rbinom(1, n, theta1)\n  \n  KL_sim[b] &lt;- log(dbinom(x_j, n, theta1)/dbinom(x_j, n, theta2))\n}\nmean(KL_sim)\n\n\n\nSi considerino ora \\(X_1\\) e \\(X_2\\) distribuite secondo distribuzioni Poisson di parametri \\(\\lambda_1\\) e \\(\\lambda_2\\). Dato che il supporto della Poisson è illimitato, per calcolare la divergenza di Kullback-Leibler bisognerebbe calcolare una serie numerica. Si proponga almeno un modo per ottenere la divergenza di Kullback-Leibler considerando \\(\\lambda_1 = 2\\) e \\(\\lambda_2 = 10\\).\n\n\n\nSoluzione\n# Modo 1: Tronco il supporto ad un elemento sufficientemente alto\n\nlambda1 &lt;- 2\nlambda2 &lt;- 10\n\nS_X &lt;- 0:100\n\np1 &lt;- dpois(S_X, lambda1)\np2 &lt;- dpois(S_X, lambda2)\nKL &lt;- sum(p1*log(p1/p2))\n\n\n# Modo 2: uso Monte Carlo:\n\nB &lt;- 15000\nlambda1 &lt;- 2\nlambda2 &lt;- 10\nKL_sim &lt;- numeric(B)\n\nfor(b in 1:B){\n  x_j &lt;- rpois(1, lambda1)\n  \n  KL_sim[b] &lt;- log(dpois(x_j, lambda1)/dpois(x_j, lambda2))\n}\n\nKL\nmean(KL_sim)\n\n\n\n\nEsercizio 4\nIn un popolare gioco di ruolo, giocatori e giocatrici devono lanciare dei dadi a 20 facce per superare delle prove.\nPer superare la prima prova, viene chiesto di lanciare \\(K\\) dadi a 20 facce. La prova si ritiene superata se almeno \\(L\\) dei \\(K\\) dadi presenta valore maggiore di 13.\n\nSi scriva una funzione prova1(K, L, B) che approssimi, tramite una simulazione basata su B repliche, la probabilità di superare la prova.\n\n\n\nSoluzione\nprova1 &lt;- function(K, L, B=2000){\n  successo &lt;- numeric(B)\n  \n  for(b in 1:B){\n    dadi &lt;- sample(1:20, K, replace=T)\n    dadi_vincenti &lt;- sum(dadi &gt; 13)\n    successo[b] &lt;- dadi_vincenti &gt; L\n  }\n  \n  return(mean(successo))\n}\n\n\n\nSi utilizzi la funzione definita al punto precedente considerando i valori \\(K = 10\\), \\(L = 6\\) e \\(B = 50000\\) per approssimare la probabilità di superare la prima prova.\n\n\n\nSoluzione\nprova1(10, 5, B=50000)\n\n\n\nSi consideri la variabile casuale \\(X\\) definita dal numero di dadi che hanno portato ad un valore maggiore di 13 tra i \\(K\\) lanciati. Si ottenga una rappresentazione grafica della funzione di probabilità di \\(X\\).\n\n\n\nSoluzione\nK &lt;- 10\nB &lt;- 50000\nsupporto &lt;- 0:K\nesiti &lt;- numeric(B)\n\nfor(b in 1:B){\n  dadi &lt;- sample(1:20, K, replace=T)\n  dadi_vincenti &lt;- sum(dadi &gt; 13)\n  esiti[b] &lt;- dadi_vincenti\n}\n\ntable(esiti)/B\n\nplot(table(esiti)/B, main = \"Distribuzione di probabilità di X\", ylab=\"Prob. (approx.)\")"
  },
  {
    "objectID": "Esercizi.html#parte-4-inferenza",
    "href": "Esercizi.html#parte-4-inferenza",
    "title": "Esercizi R",
    "section": "Parte 4: Inferenza",
    "text": "Parte 4: Inferenza"
  }
]